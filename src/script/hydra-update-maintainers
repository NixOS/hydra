#! /usr/bin/env perl

# Heavily inspired by `hydra-backfill-ids`.
#
# It is mandatory to run this after `upgrade-69.sql` was executed!
# If the migration was done already, the script will exit early.
#
# * `VACUUM;` at beginning and end of the script.
# * Insert all maintainer emails into the `Maintainers` table that can be found
#   in the `Builds` table.
# * Set the associations to the builds in `BuildsByMaintainers`.
# * Everything will happen in 5k batches of rows.

use strict;
use warnings;

use utf8;
use Hydra::Model::DB;

STDOUT->autoflush();
STDERR->autoflush(1);
binmode STDERR, ":encoding(utf8)";

my $db = Hydra::Model::DB->new();
my $vacuum = $db->storage->dbh->prepare("VACUUM;");

die "syntax: $0\n" unless @ARGV == 0;

print STDERR "Checking if script needs to be executed\n";
my $column_check = $db->storage->dbh->prepare(<<QUERY);
SELECT EXISTS (
    SELECT 1 FROM information_schema.columns
    WHERE table_name = 'builds'
    AND column_name = 'maintainers'
);
QUERY

$column_check->execute();
if ($column_check->fetchrow_array == 0) {
    print STDERR "Migration seems to be done already\n";
    exit(0);
}

sub updateMaintainers {
    my $rows_per_batch = $ENV{'HYDRA_UPDATE_MAINTAINERS_BATCH_SIZE'} // 5000;
    my $maintainers = $db->storage->dbh->prepare(<<QUERY);
INSERT INTO Maintainers (email)
    SELECT DISTINCT rs.maintainer FROM (
        SELECT s.maintainer AS maintainer, b.id
        FROM Builds b, unnest(string_to_array(b.maintainers, ', ')) s(maintainer)
        LEFT OUTER JOIN Maintainers m
        ON s.maintainer = m.email
        WHERE b.id >= ?
        AND m.email IS NULL
        ORDER BY b.id ASC
        LIMIT ?
    ) rs
QUERY

    my $new_entries = $db->storage->dbh->prepare(<<QUERY);
WITH
    progress AS (
        INSERT INTO BuildsByMaintainers (maintainer_id, build_id)
            SELECT DISTINCT m.id, b.id
            FROM Builds b, unnest(string_to_array(b.maintainers, ', ')) s(maintainer)
            INNER JOIN Maintainers m
            ON m.email = s.maintainer
            WHERE b.id >= ?
            AND b.id NOT IN (
                SELECT build_id FROM BuildsByMaintainers
                WHERE build_id = b.id
                AND maintainer_id = m.id
            )
            ORDER BY b.id ASC
            LIMIT ?
            RETURNING build_id
    )
SELECT
    (SELECT COUNT(*) FROM progress) AS affected,
    MAX(progress.build_id) AS highest
FROM progress;
QUERY

    my $affected = 0;
    my $highest = 0;
    do {
        print STDERR "Saving additional batch of maintainers...\n";
        $maintainers->execute($highest, $rows_per_batch);

        print STDERR "Creating associations to existing builds...\n";
        $new_entries->execute($highest, $rows_per_batch);

        ($affected, $highest) = $new_entries->fetchrow_array;

        print STDERR "Running VACUUM;\n";
        $vacuum->execute();

        if ($affected != 0) {
            print STDERR "Updated $affected builds, latest ID was $highest\n";
        } else {
            print STDERR "Nothing left...\n";
        }
    } while ($affected > 0);

    my $cleanup = $db->storage->dbh->prepare(<<QUERY);
ALTER TABLE Builds DROP COLUMN IF EXISTS maintainers;
QUERY

    $cleanup->execute();
}

print STDERR "Beginning with a VACUUM\n";
$vacuum->execute();

updateMaintainers();

$vacuum->execute();
