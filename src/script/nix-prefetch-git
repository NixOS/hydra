#!/bin/bash -e

url=
rev=
expHash=
hashType=$NIX_HASH_ALGO
deepClone=$NIX_PREFETCH_GIT_DEEP_CLONE
leaveDotGit=$NIX_PREFETCH_GIT_LEAVE_DOT_GIT
builder=

if test -n "$deepClone"; then
  deepClone=true
else
  deepClone=false
fi

if test "$leaveDotGit" != 1; then
  leaveDotGit=
else
  leaveDotGit=true
fi


argi=0
argfun=""
for arg; do
  if test -z "$argfun"; then
    case $arg in
      --out) argfun=set_out;;
      --url) argfun=set_url;;
      --rev) argfun=set_rev;;
      --hash) argfun=set_hashType;;
      --token) argfun=set_token;;
      --deepClone) deepClone=true;;
      --no-deepClone) deepClone=false;;
      --leave-dotGit) leaveDotGit=true;;
      --builder) builder=true;;
      *)
          argi=$(($argi + 1))
          case $argi in
              1) url=$arg;;
              2) rev=$arg;;
              3) expHash=$arg;;
              *) exit 1;;
          esac
          ;;
    esac
  else
    case $argfun in
      set_*)
        var=$(echo $argfun | sed 's,^set_,,')
        eval $var=$arg
        ;;
    esac
    argfun=""
  fi
done

usage(){
    echo  >&2 "syntax: nix-prefetch-git [options] [URL [REVISION [EXPECTED-HASH]]]

Options:
      --out path      Path where the output would be stored.
      --url url       Any url understand by 'git clone'.
      --rev ref       Any sha1 or references (such as refs/heads/master)
      --hash h        Expected hash.
      --token token   The token to use then cloning submodules from https://github.com
      --deepClone     Clone submodules recursively.
      --no-deepClone  Do not clone submodules.
      --leave-dotGit  Keep the .git directories.
      --builder       Clone as fetchgit does, but url, rev, and out option are mandatory.
"
    exit 1
}

if test -z "$url"; then
  usage
fi


init_remote(){
    local url=$1;
    git init;
    git remote add origin $url;
}

# Return the reference of an hash if it exists on the remote repository.
ref_from_hash(){
    local hash=$1;
    git ls-remote origin | sed -n "\,$hash\t, { s,\(.*\)\t\(.*\),\2,; p; q}"
}

# Return the hash of a reference if it exists on the remote repository.
hash_from_ref(){
    local ref=$1
    git ls-remote origin | sed -n "\,\t$ref, { s,\(.*\)\t\(.*\),\1,; p; q}"
}

# Fetch everything and checkout the right sha1
checkout_hash(){
    local hash="$1";
    local ref="$2";

    if test -z "$hash"; then
        hash=$(hash_from_ref $ref);
    fi;

    git fetch ${builder:+--progress} origin || return 1
    git checkout -b fetchgit $hash || return 1
}

# Fetch only a branch/tag and checkout it.
checkout_ref(){
    local hash="$1";
    local ref="$2";

    if "$deepClone"; then
	# The caller explicitly asked for a deep clone.  Deep clones
	# allow "git describe" and similar tools to work.  See
	# http://thread.gmane.org/gmane.linux.distributions.nixos/3569
	# for a discussion.
	return 1
    fi

    if test -z "$ref"; then
        ref=$(ref_from_hash $hash);
    fi;

    if test -n "$ref"; then
        # --depth option is ignored on http repository.
        git fetch ${builder:+--progress} --depth 1 origin +"$ref" || return 1
        git checkout -b fetchgit FETCH_HEAD || return 1
    else
        return 1;
    fi;
}

#
# URI parsing function
#
# The function creates global variables with the parsed results.
# It returns 0 if parsing was successful or non-zero otherwise.
#
# [schema://][user[:password]@]host[:port][/path][?[arg1=val1]...][#fragment]
#
# from http://wp.vpalos.com/537/uri-parsing-using-bash-built-in-features/
#
# Modified regex to support 'file:///' patterns
#
# TODO: Support ssh://example.com:some/path
function uri_parser() {
    # uri capture
    uri="$@"

    # safe escaping
    uri="${uri//\`/%60}"
    uri="${uri//\"/%22}"

    # top level parsing
    pattern='^(([a-z]{3,5})://)?((([^:\/]*)(:([^@\/]*))?@)?([^:\/?]+)(:([0-9]+))?)(\/[^?]*)?(\?[^#]*)?(#.*)?$'
    [[ "$uri" =~ $pattern ]] || return 1;

    # component extraction
    uri=${BASH_REMATCH[0]}
    uri_schema=${BASH_REMATCH[2]}
    uri_address=${BASH_REMATCH[3]}
    uri_user=${BASH_REMATCH[5]}
    uri_password=${BASH_REMATCH[7]}
    uri_host=${BASH_REMATCH[8]}
    uri_port=${BASH_REMATCH[10]}
    uri_path=${BASH_REMATCH[11]}
    uri_query=${BASH_REMATCH[12]}
    uri_fragment=${BASH_REMATCH[13]}

    # path parsing
    count=0
    path="$uri_path"
    pattern='^/+([^/]+)'
    while [[ $path =~ $pattern ]]; do
        eval "uri_parts[$count]=\"${BASH_REMATCH[1]}\""
        path="${path:${#BASH_REMATCH[0]}}"
        let count++
    done

    # query parsing
    count=0
    query="$uri_query"
    pattern='^[?&]+([^= ]+)(=([^&]*))?'
    while [[ $query =~ $pattern ]]; do
        eval "uri_args[$count]=\"${BASH_REMATCH[1]}\""
        eval "uri_arg_${BASH_REMATCH[1]}=\"${BASH_REMATCH[3]}\""
        query="${query:${#BASH_REMATCH[0]}}"
        let count++
    done

    # return success
    return 0
}

# Try to insert an authentication token before github.com
#
# The first argument must be an authentication token to insert before the
# hostname.
#
# The second argument must be the URI.
#
# sets the variable `authUri` to the given uri with the authentication token
# inserted iff the input is of the form https://github.com/something and the
# token is non empty.
#
# The authentication token is inserted between `https://` and `github.com`
#
# If the token is empty `authUri` is set to the input uri.
#
# On any other input `authUri` is set to the input uri.
maybeAddGithubAuthentication(){
  local token="$1";
  local uri="$2";
  echoerr() { printf "%s\n" "$*" >&2; }

  if [ -z ${var+x} ]; then
    authUri="$uri";
    return 0;
  fi;

  uri_parser "$uri" || { echoerr "Error: Malformed URI!"; authUri="$uri"; return 1; }

  [[ "$uri_schema" = "https" ]];
  local isHttps=$?;
  [[ "$uri_host" = "github.com" ]];
  local isGithub=$?;
  [[ -z "$uri_user" ]];
  local noUserSpecified=$?;

  if ((noUserSpecified == 1)); then
    authUri="$uri";
    return 0;
  fi;

  if ((isHttps == 1)); then
    if ((isGithub == 0)); then
      echoerr "Warning: github token will not be applied to non-https uri: $uri";
    fi;
    authUri="$uri";
    return 0;
  fi;

  authUri="$uri_schema://$token@$uri_host:$uri_port$uri_path$uri_query$uri_fragment";
}

# Update submodules
init_submodules(){
    # Add urls into .git/config file
    git submodule init

    # list submodule directories and their hashes
    git submodule status |
    while read l; do
        # checkout each submodule
        local hash=$(echo $l | sed 's,^-\([0-9a-f]*\) \(.*\)$,\1,');
        local dir=$(echo $l | sed 's,^-\([0-9a-f]*\) \(.*\)$,\2,');
        local url=$(sed -n "\,$dir, { :loop; n; s,^.*url = ,,; T loop; p; q }" .git/config);

        maybeAddGithubAuthentication $token $url
        local authenticatedUrl="$authUri"

        clone "$dir" "$authenticatedUrl" "$hash" "";
    done;
}

clone(){
    local top=$(pwd)
    local dir="$1"
    local url="$2"
    local hash="$3"
    local ref="$4"

    cd $dir;

    # Initialize the repository.
    init_remote "$url";

    # Download data from the repository.
    checkout_ref "$hash" "$ref" ||
    checkout_hash "$hash" "$ref" || (
        echo 1>&2 "Unable to checkout $hash$ref from $url.";
        exit 1;
    )

    # Checkout linked sources.
    init_submodules;

    if [ -z "$builder" -a -f .topdeps ]; then
	if tg help 2>&1 > /dev/null
	then
	    echo "populating TopGit branches..."
	    tg remote --populate origin
	else
	    echo "WARNING: would populate TopGit branches but TopGit is not available" >&2
	    echo "WARNING: install TopGit to fix the problem" >&2
	fi
    fi

    cd $top;
}

clone_user_rev() {
    local dir="$1"
    local url="$2"
    local rev="$3"

    # Perform the checkout.
    case "$rev" in
        HEAD|refs/*)
            clone "$dir" "$url" "" "$rev" 1>&2;;
        [0-9a-f]*)
            if test -z "$(echo $rev | tr -d 0123456789abcdef)"; then
                clone "$dir" "$url" "$rev" "" 1>&2;
            else
                echo 1>&2 "Bad commit hash or bad reference.";
                exit 1;
            fi;;
        "")
            clone "$dir" "$url" "" "HEAD" 1>&2;;
    esac

    # Allow doing additional processing before .git removal
    eval "$NIX_PREFETCH_GIT_CHECKOUT_HOOK"
    if test -z "$leaveDotGit"; then
	echo "removing \`.git'..." >&2
        find $dir -name .git\* | xargs rm -rf
    fi
}

if test -n "$builder"; then
  test -n "$out" -a -n "$url" -a -n "$rev" || usage
  mkdir $out
  clone_user_rev "$out" "$url" "$rev"
else
  if test -z "$hashType"; then
      hashType=sha256
  fi

  # If the hash was given, a file with that hash may already be in the
  # store.
  if test -n "$expHash"; then
      finalPath=$(nix-store --print-fixed-path --recursive "$hashType" "$expHash" git-export)
      if ! nix-store --check-validity "$finalPath" 2> /dev/null; then
          finalPath=
      fi
      hash=$expHash
  fi

  # If we don't know the hash or a path with that hash doesn't exist,
  # download the file and add it to the store.
  if test -z "$finalPath"; then

      tmpPath="$(mktemp -d "${TMPDIR:-/tmp}/git-checkout-tmp-XXXXXXXX")"
      trap "rm -rf \"$tmpPath\"" EXIT

      tmpFile="$tmpPath/git-export"
      mkdir "$tmpFile"

      # Perform the checkout.
      clone_user_rev "$tmpFile" "$url" "$rev"

      # Compute the hash.
      hash=$(nix-hash --type $hashType $hashFormat $tmpFile)
      if ! test -n "$QUIET"; then echo "hash is $hash" >&2; fi

      # Add the downloaded file to the Nix store.
      finalPath=$(nix-store --add-fixed --recursive "$hashType" $tmpFile)

      if test -n "$expHash" -a "$expHash" != "$hash"; then
          echo "hash mismatch for URL \`$url'"
          exit 1
      fi
  fi

  if ! test -n "$QUIET"; then echo "path is $finalPath" >&2; fi

  echo $hash

  if test -n "$PRINT_PATH"; then
      echo $finalPath
  fi
fi
